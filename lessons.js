window.DEV_LESSONS = [
  {
    "id": 1,
    "lang": "Python",
    "level": "Beginner",
    "title": "Установка Python и первый запуск",
    "tags": [
      "установка",
      "pip",
      "vscode"
    ],
    "explanation": "Этот урок про подготовку окружения: установка Python 3 и запуск первого скрипта. После установки важно проверить, что команда `python --version` (или `py --version` на Windows) работает в терминале — это значит, что Python доступен в PATH. Затем создаётся файл `hello.py` и выполняется командой `python hello.py`. Для проектов полезно привыкнуть к виртуальным окружениям: `python -m venv .venv` изолирует библиотеки, чтобы они не смешивались между разными задачами. Если используешь VS Code, выбери интерпретатор из `.venv`, чтобы запуск и подсветка ошибок работали правильно. Попробуй запустить скрипт несколько раз и изменять текст вывода — так ты поймёшь базовый цикл «редактировать → запускать → смотреть результат».",
    "code": "# hello.py\nprint(\"Привет, Python!\")",
    "tasks": [
      "Установи Python и проверь версию.",
      "Создай `hello.py` и запусти.",
      "Создай и активируй `.venv`."
    ]
  },
  {
    "id": 2,
    "lang": "Python",
    "level": "Beginner",
    "title": "print(): вывод и параметры sep/end",
    "tags": [
      "print",
      "вывод",
      "форматирование"
    ],
    "explanation": "`print()` — основной способ вывести данные в консоль, чтобы увидеть, что делает программа. По умолчанию `print` разделяет несколько значений пробелом и ставит перевод строки в конце. Параметр `sep` меняет разделитель (например, `;` или ` | `), а `end` задаёт, чем заканчивать вывод (например, пустой строкой, чтобы продолжить печать в той же строке). Эти параметры полезны при форматировании таблиц, логов и аккуратного отчёта. Привыкай печатать не только строки, но и переменные, выражения и подсказки для пользователя. Практика: выведи несколько значений разными `sep`, затем убери перенос строки через `end` и посмотри, как меняется вывод.",
    "code": "print(\"A\", \"B\", \"C\", sep=\" | \")\nprint(\"Без переноса...\", end=\" \")\nprint(\"продолжение\")",
    "tasks": [
      "Выведи 1;2;3 используя sep=';'.",
      "Сделай вывод без переноса строки через end."
    ]
  },
  {
    "id": 3,
    "lang": "Python",
    "level": "Beginner",
    "title": "Переменные и типы данных",
    "tags": [
      "типы",
      "int",
      "float",
      "str",
      "bool"
    ],
    "explanation": "Переменная в Python — это имя, которое ссылается на значение. Самые частые типы: `int` (целые числа), `float` (дробные), `str` (строки) и `bool` (`True/False`). Python динамически типизирован: тип не объявляют заранее, но его важно понимать, чтобы не получить неожиданные ошибки (например, сложение строки и числа). Тип можно проверить через `type(x)`, а преобразование сделать функциями `int()`, `float()`, `str()`. Хорошая привычка — давать понятные имена переменным и хранить в них одну “идею”: возраст, цену, имя, флаг состояния. Попробуй сам менять значения и наблюдать, как меняется тип и результат операций.",
    "code": "x = 10\npi = 3.14\nname = \"Mira\"\nok = True\nprint(type(x), type(pi), type(name), type(ok))",
    "tasks": [
      "Создай 4 переменные разных типов и выведи type().",
      "Преобразуй '42' в число и прибавь 8."
    ]
  },
  {
    "id": 4,
    "lang": "Python",
    "level": "Beginner",
    "title": "input(): ввод и преобразования",
    "tags": [
      "input",
      "int",
      "float"
    ],
    "explanation": "Функция `input()` читает то, что ввёл пользователь, и **всегда** возвращает строку. Поэтому даже если человек ввёл «25», программа получила текст `'25'`. Если нужны вычисления, преобразуй ввод в `int` или `float`, иначе сложение будет “склеивать” строки. Частая схема: показать понятную подсказку в `input(\"...\")`, затем привести тип и использовать в формуле (сумма, площадь, проценты). В реальной жизни пользователи могут вводить неправильные данные, поэтому позже добавим защиту через `try/except`. Пока запомни правило: **input → строка → преобразование → расчёт**. Практика: попробуй ввести разные значения и посмотри, что будет без `int()` и с `int()`.",
    "code": "a = int(input(\"a = \"))\nb = int(input(\"b = \"))\nprint(\"Сумма:\", a + b)",
    "tasks": [
      "Спроси имя и выведи приветствие.",
      "Спроси длину и ширину и выведи площадь."
    ]
  },
  {
    "id": 5,
    "lang": "Python",
    "level": "Beginner",
    "title": "Арифметика: / // % **",
    "tags": [
      "арифметика",
      "операторы"
    ],
    "explanation": "В Python есть несколько видов деления и полезные арифметические операторы. `/` делает обычное деление и возвращает `float`, даже если делится “ровно”. `//` — целочисленное деление (берёт только целую часть), `%` — остаток от деления, а `**` — возведение в степень. Остаток очень полезен для проверок: `n % 2 == 0` означает, что число чётное, а `n % 10` даёт последнюю цифру. Эти операции встречаются в задачах про время, разбиение на страницы, проверку кратности и работу с индексами. Практика: поэкспериментируй с разными `a` и `b` и сравни `/` и `//`.",
    "code": "a, b = 7, 3\nprint(a / b)\nprint(a // b)\nprint(a % b)\nprint(a ** b)",
    "tasks": [
      "Проверь чётность числа n.",
      "Выведи последнюю цифру числа через n%10."
    ]
  },
  {
    "id": 6,
    "lang": "Python",
    "level": "Beginner",
    "title": "Строки: индексы, срезы, методы",
    "tags": [
      "строки",
      "slicing",
      "methods"
    ],
    "explanation": "Строка (`str`) — последовательность символов, поэтому у неё есть индексы: `s[0]` — первый символ, `s[-1]` — последний. Срезы `s[a:b]` позволяют взять кусок строки (конец `b` не включается), а `s[::step]` берёт каждый `step`‑й символ. У строк много готовых методов: `strip()` убирает пробелы по краям, `lower()/upper()` меняют регистр, `replace()` заменяет подстроки. Это основа обработки ввода пользователя, текстовых файлов и данных из интернета. Важно помнить: строки **неизменяемы**, методы возвращают новую строку. Практика: возьми любое предложение и попробуй сделать из него «чистую» версию: убрать пробелы, привести к lower и заменить пробелы на `_`.",
    "code": "s = \"  Python  \"\nprint(s.strip())\nprint(\"Python\"[0], \"Python\"[-1])\nprint(\"Python\"[1:4])\nprint(\"hello world\".replace(\" \", \"_\"))",
    "tasks": [
      "Выведи длину строки и первый/последний символ.",
      "Замени пробелы на '-'."
    ]
  },
  {
    "id": 7,
    "lang": "Python",
    "level": "Beginner",
    "title": "f-строки и формат чисел",
    "tags": [
      "f-string",
      "format"
    ],
    "explanation": "f-строки (`f\"...\"`) — самый удобный способ вставлять значения переменных прямо в текст. В фигурных скобках можно писать выражения: `f\"{a+b}\"`. Также f-строки поддерживают форматирование чисел: `{x:.2f}` оставляет 2 знака после запятой — удобно для денег и процентов, а `{n:,}` добавляет разделители тысяч (в англ. формате). Форматирование делает вывод аккуратным и профессиональным: отчёты, чеки, статистика, результаты задач. Полезная привычка — форматировать дробные числа, иначе из‑за особенностей `float` могут появляться длинные “хвосты”. Практика: выведи одну и ту же цену в разных форматах и сравни читабельность.",
    "code": "name = \"Nodir\"\nscore = 93.4567\nprint(f\"Привет, {name}! Балл: {score:.2f}\")",
    "tasks": [
      "Выведи цену 12345.6 как 12345.60.",
      "Спроси имя/возраст и выведи f-string."
    ]
  },
  {
    "id": 8,
    "lang": "Python",
    "level": "Beginner",
    "title": "Условия if/elif/else",
    "tags": [
      "if",
      "условия"
    ],
    "explanation": "Условные операторы **if**, **elif** и **else** позволяют управлять потоком кода на основе условий и помогают программе принимать решения. `if` начинается с выражения, которое должно возвращать `True` или `False`; после него ставится двоеточие. Код, связанный с этим условием, пишется с отступом — отступы в Python определяют границы блока. `elif` (сокращение от *else if*) проверяет альтернативное условие, если предыдущие проверки не сработали; `elif` может быть несколько подряд. `else` не содержит условия и выполняется, если ни одно из предыдущих условий не оказалось истинным; он не обязателен. Такая конструкция удобна, когда нужно обработать разные варианты поведения (оценки, скидки, доступ по возрасту).",
    "code": "x = int(input(\"Число: \"))\nif x > 0:\n    print(\"Положительное\")\nelif x < 0:\n    print(\"Отрицательное\")\nelse:\n    print(\"Ноль\")",
    "tasks": [
      "Сравни два числа и выведи большее.",
      "Проверь делимость на 3 и 5."
    ]
  },
  {
    "id": 9,
    "lang": "Python",
    "level": "Beginner",
    "title": "Логика and/or/not",
    "tags": [
      "логика",
      "and",
      "or",
      "not"
    ],
    "explanation": "Логические операторы помогают объединять условия. `and` требует, чтобы **оба** условия были истинны, `or` — чтобы истинно было **хотя бы одно**, а `not` инвертирует результат. Очень частая проверка диапазона выглядит так: `18 <= age <= 60`. С логикой легко формулировать правила: «пароль длиннее 8 и содержит цифру» или «число кратно 3 или 5». Помни про читаемость: если условие становится длинным, разбей его на несколько переменных с понятными именами (`is_long`, `has_digit`). Тогда код проще проверять и исправлять. Практика: составь условие для доступа к сайту по возрасту и наличию подписки и протестируй его на нескольких примерах.",
    "code": "age = int(input(\"Возраст: \"))\nif 18 <= age <= 60:\n    print(\"В диапазоне\")\nelse:\n    print(\"Вне диапазона\")",
    "tasks": [
      "Проверь: пароль длиной >= 8 и содержит цифру (упрощённо).",
      "Проверь: число кратно 3 или 5."
    ]
  },
  {
    "id": 10,
    "lang": "Python",
    "level": "Beginner",
    "title": "Цикл while",
    "tags": [
      "while",
      "циклы"
    ],
    "explanation": "Цикл `while` выполняет блок кода, пока условие остаётся истинным. Он удобен, когда заранее не известно количество повторений: например, «пока пользователь не введёт правильное значение» или «пока сумма не превысит лимит». Главное правило: внутри цикла должно меняться состояние, иначе получится бесконечный цикл. Обычно используют счётчик `i` и увеличивают его (`i += 1`) или читают новые данные. `while` отлично подходит для меню команд в консольных программах. Практика: сделай ввод числа, который повторяется, пока пользователь не введёт число в нужном диапазоне, и выведи сообщение об ошибке для неправильного ввода.",
    "code": "i = 1\nwhile i <= 5:\n    print(i)\n    i += 1",
    "tasks": [
      "Выведи числа 1..n.",
      "Найди сумму 1..n."
    ]
  },
  {
    "id": 11,
    "lang": "Python",
    "level": "Beginner",
    "title": "Цикл for и range()",
    "tags": [
      "for",
      "range"
    ],
    "explanation": "Цикл `for` перебирает элементы последовательности: список, строку, диапазон чисел. `range(n)` даёт числа от 0 до `n-1`, а `range(a, b)` — от `a` до `b-1`. Это основной инструмент, когда число повторений известно: вывести таблицу, посчитать сумму, пройти по индексам. В `for` удобно делать вычисления “на лету”: квадрат числа, накопление суммы, подсчёт чётных значений. Привыкай к мысли, что `for` — это «для каждого элемента», а не только счётчик. Тогда ты чаще будешь писать `for x in items`, а не `for i in range(...)`, и код станет чище.",
    "code": "for i in range(1, 11):\n    print(i, i*i)",
    "tasks": [
      "Таблица умножения на 7.",
      "Сумма чётных 1..n."
    ]
  },
  {
    "id": 12,
    "lang": "Python",
    "level": "Beginner",
    "title": "break/continue",
    "tags": [
      "break",
      "continue"
    ],
    "explanation": "`break` и `continue` управляют циклом. `continue` пропускает текущую итерацию и сразу переходит к следующей — полезно, когда нужно игнорировать часть данных. `break` полностью завершает цикл — удобно при поиске первого совпадения или когда дальнейшие вычисления не нужны. Используй их аккуратно: слишком много `break/continue` делает логику запутанной. Хорошая практика — сначала написать простой цикл, а затем добавить `continue` для пропусков и `break` для раннего выхода, если это реально упрощает задачу. Практика: найди первое число, которое удовлетворяет условию, и останови цикл через `break`, затем сравни с вариантом без `break`.",
    "code": "for i in range(1, 21):\n    if i % 3 == 0:\n        continue\n    if i > 17:\n        break\n    print(i)",
    "tasks": [
      "Выведи 1..50, пропуская кратные 4.",
      "Найди первое число >100, делящееся на 7."
    ]
  },
  {
    "id": 13,
    "lang": "Python",
    "level": "Beginner",
    "title": "Списки: основы",
    "tags": [
      "list",
      "списки"
    ],
    "explanation": "Список (`list`) хранит упорядоченные элементы и позволяет изменять их: добавлять, удалять, заменять по индексу. Доступ идёт по индексу, как у строк: `a[0]`, `a[-1]`. Списки встречаются везде: набор чисел, список задач, товары в корзине, строки из файла. Освой базовые операции: создать список, добавить через `append`, заменить элемент, пройти циклом `for`. Полезно помнить, что список может содержать разные типы, но в задачах чаще держат однотипные элементы для простоты. Практика: собери список чисел из ввода, посчитай сумму и найди максимум — это типичный набор действий для начинающего.",
    "code": "nums = [10, 20, 30]\nnums.append(40)\nnums[1] = 25\nprint(nums, nums[0], nums[-1])",
    "tasks": [
      "Список из 5 чисел — сумма.",
      "Поменяй местами первый и последний."
    ]
  },
  {
    "id": 14,
    "lang": "Python",
    "level": "Beginner",
    "title": "Методы списков",
    "tags": [
      "list",
      "methods"
    ],
    "explanation": "У списков есть методы для типичных операций. `append(x)` добавляет элемент в конец, `extend([...])` добавляет сразу несколько, `insert(i, x)` вставляет по индексу. Удаление делается через `remove(x)` (по значению) или `pop(i)` (по индексу; без аргумента — последний элемент). `count` и `index` помогают узнать количество и позицию значения. Важно: `remove` удаляет **первое** совпадение, а `pop` возвращает удалённый элемент. Практика: сделай список покупок, добавляй и удаляй элементы разными способами и следи, как меняется список.",
    "code": "a = [1,2,3]\na.append(4)\na.extend([5,6])\na.insert(0, 0)\na.remove(3)\nlast = a.pop()\nprint(a, last)",
    "tasks": [
      "Удалить все нули из списка.",
      "Вставь 999 в середину."
    ]
  },
  {
    "id": 15,
    "lang": "Python",
    "level": "Beginner",
    "title": "Сортировка: sort/sorted",
    "tags": [
      "sorting",
      "sorted",
      "sort"
    ],
    "explanation": "Сортировка упорядочивает данные: числа по возрастанию, слова по алфавиту, записи по цене. `sorted(list)` возвращает новый отсортированный список, а `list.sort()` сортирует “на месте”. Для обратного порядка используется `reverse=True`. Сортировка часто нужна перед поиском, вычислением медианы или красивым выводом рейтинга. Помни: элементы должны быть сравнимыми (не смешивай числа и строки). Для сложных объектов пригодится параметр `key`. Практика: отсортируй список слов по алфавиту и по длине, сравни результаты и подумай, какой вариант полезнее пользователю.",
    "code": "nums = [5, 1, 9, 2]\nprint(sorted(nums))\nnums.sort(reverse=True)\nprint(nums)",
    "tasks": [
      "Отсортируй слова по алфавиту.",
      "Отсортируй числа по убыванию."
    ]
  },
  {
    "id": 16,
    "lang": "Python",
    "level": "Beginner",
    "title": "Кортежи tuple",
    "tags": [
      "tuple"
    ],
    "explanation": "Кортеж (`tuple`) похож на список, но он **неизменяемый**. Это полезно, когда значения не должны случайно меняться: координаты, размеры, пары (ключ, значение). Кортежи удобно распаковывать: `x, y = point`. Если нужно менять элементы — выбирай список, если нужно “зафиксировать” набор — кортеж. Кортежи часто возвращают из функций, когда нужно вернуть несколько результатов сразу. Практика: напиши функцию, которая возвращает (минимум, максимум) списка, и распакуй результат в две переменные.",
    "code": "point = (10, 20)\nx, y = point\nprint(x, y)",
    "tasks": [
      "Создай кортеж из 3 значений и распакуй.",
      "Почему tuple нельзя менять?"
    ]
  },
  {
    "id": 17,
    "lang": "Python",
    "level": "Beginner",
    "title": "Множества set",
    "tags": [
      "set",
      "unique"
    ],
    "explanation": "Множество (`set`) хранит уникальные элементы без повторов. Оно идеально, когда нужно убрать дубликаты, быстро проверить принадлежность (`x in s`) или найти пересечение двух наборов. Операции множеств: объединение `|`, пересечение `&`, разность `-`. Порядок элементов в `set` не гарантируется, поэтому для вывода часто делают `sorted(set)`. Практика: возьми строку, разбей на слова, посчитай уникальные слова. Затем сравни два множества слов из разных строк и найди общие элементы.",
    "code": "a = {1,2,2,3}\nb = {3,4,5}\nprint(a, a|b, a&b, a-b)",
    "tasks": [
      "Посчитай уникальные слова в строке.",
      "Найди общие элементы двух списков."
    ]
  },
  {
    "id": 18,
    "lang": "Python",
    "level": "Beginner",
    "title": "Словари dict",
    "tags": [
      "dict",
      "словарь"
    ],
    "explanation": "Словарь (`dict`) хранит пары **ключ → значение** и часто заменяет простую “базу данных”. Доступ к значению — `d[key]`, а безопасный способ — `d.get(key, default)`, чтобы не получить ошибку, если ключа нет. Ключи обычно строки или числа, значения могут быть любыми. Словари применяются в настройках, данных пользователя, товарах, статистике и в JSON. Практика: создай словарь товара с `price` и `qty`, посчитай стоимость и добавь поле `total`. Попробуй вывести `get` для несуществующего ключа и посмотри разницу с `d[key]`.",
    "code": "user = {\"name\":\"Amina\", \"age\":18}\nuser[\"city\"] = \"Tashkent\"\nprint(user[\"name\"])\nprint(user.get(\"email\",\"нет\"))",
    "tasks": [
      "Словарь товара: price, qty → сумма.",
      "Спроси ключ и выведи через get."
    ]
  },
  {
    "id": 19,
    "lang": "Python",
    "level": "Beginner",
    "title": "Перебор dict.items()",
    "tags": [
      "dict",
      "loop"
    ],
    "explanation": "`d.items()` возвращает пары (ключ, значение), поэтому удобно писать `for k, v in d.items()`. Это основа анализа данных: найти максимум, посчитать сумму, отфильтровать по условию. Полезный приём: `max(d.items(), key=lambda x: x[1])` — найти пару с максимальным значением. Практика: сделай словарь «имя → балл», выведи тех, у кого балл выше порога, затем найди лучшего ученика и средний балл по всем значениям.",
    "code": "scores = {\"Ali\":90, \"Mira\":85, \"Nodir\":97}\nbest = max(scores.items(), key=lambda x: x[1])\nprint(best)",
    "tasks": [
      "Найди средний балл.",
      "Выведи тех, у кого >= 90."
    ]
  },
  {
    "id": 20,
    "lang": "Python",
    "level": "Beginner",
    "title": "Функции def/return",
    "tags": [
      "functions",
      "def",
      "return"
    ],
    "explanation": "Функции помогают не повторять код и делают программу структурированной. Функция объявляется через `def`, принимает параметры и возвращает результат через `return`. Если `return` не указан, вернётся `None`. Хорошая функция делает одну задачу: проверить пароль, посчитать площадь, преобразовать строку. Это упрощает отладку и повторное использование. Практика: напиши `square(n)` и `max2(a, b)`, протестируй на нескольких значениях, а затем используй эти функции внутри другой задачи (например, обработка списка чисел).",
    "code": "def area(w, h):\n    return w * h\n\nprint(area(3, 4))",
    "tasks": [
      "square(n)",
      "max2(a,b)"
    ]
  },
  {
    "id": 21,
    "lang": "Python",
    "level": "Intermediate",
    "title": "Область видимости",
    "tags": [
      "scope"
    ],
    "explanation": "Область видимости показывает, какие переменные доступны в разных местах программы. Переменные, созданные внутри функции, обычно локальные и “живут” только там — это защищает код от случайных изменений. Использовать `global` можно, но лучше избегать: он делает программу сложнее и увеличивает риск багов. Правильный стиль — передавать данные в функцию параметрами и возвращать результат через `return`. Если нужно хранить состояние, чаще используют структуру данных или класс. Практика: сделай функцию `inc(x)`, которая возвращает `x+1`, и сравни её с вариантом, где ты пытаешься увеличивать глобальную переменную. Так ты увидишь, почему “чистые” функции проще тестировать.",
    "code": "count = 0\ndef inc(c):\n    return c + 1\n\ncount = inc(count)\nprint(count)",
    "tasks": [
      "Сделай счётчик кликов как функцию inc.",
      "Почему global хуже?"
    ]
  },
  {
    "id": 22,
    "lang": "Python",
    "level": "Intermediate",
    "title": "Параметры по умолчанию",
    "tags": [
      "defaults"
    ],
    "explanation": "Параметры по умолчанию позволяют вызывать функцию проще: если аргумент не передан, используется заранее заданное значение. Это удобно для типичных случаев (например, скидка 10% или город по умолчанию). Python также поддерживает именованные аргументы, что делает вызов читаемым: `greet(name=\"Ali\", city=\"Samarkand\")`. Важно помнить: значения по умолчанию вычисляются один раз при определении функции, поэтому изменяемые объекты (списки, словари) лучше не ставить напрямую. Практика: напиши `discount(price, percent=10)` и протестируй разные варианты вызова. Затем попробуй сделать параметр списка по умолчанию и посмотри, как он “накапливает” значения между вызовами.",
    "code": "def greet(name, city=\"Tashkent\"):\n    return f\"Привет, {name} из {city}!\"\n\nprint(greet(\"Amina\"))\nprint(greet(\"Ali\", city=\"Samarkand\"))",
    "tasks": [
      "discount(price, percent=10)",
      "Вызови с percent=25"
    ]
  },
  {
    "id": 23,
    "lang": "Python",
    "level": "Intermediate",
    "title": "*args и **kwargs",
    "tags": [
      "args",
      "kwargs"
    ],
    "explanation": "`*args` и `**kwargs` делают функции гибкими. `*args` собирает любое количество позиционных аргументов в кортеж, а `**kwargs` собирает именованные аргументы в словарь. Это удобно, когда ты не знаешь заранее, сколько значений передадут: сумма, среднее, форматирование данных, настройки. Эти конструкции часто встречаются в декораторах и библиотечном коде. Но важно сохранять ясность: если функция принимает всё подряд, пользователю трудно понять, что ожидается. Практика: напиши `total(*nums)` и `show(**data)` для красивого вывода ключей и значений. Затем передай разные наборы аргументов и сравни, как меняется результат.",
    "code": "def total(*nums):\n    return sum(nums)\n\ndef show(**data):\n    return \", \".join(f\"{k}={v}\" for k,v in data.items())\n\nprint(total(1,2,3))\nprint(show(name=\"Mira\", age=18))",
    "tasks": [
      "avg(*nums)",
      "make_user(**kwargs)"
    ]
  },
  {
    "id": 24,
    "lang": "Python",
    "level": "Intermediate",
    "title": "List comprehension",
    "tags": [
      "comprehension"
    ],
    "explanation": "Списковое включение — компактный способ создать новый список. Формат `[expr for x in xs if cond]` позволяет одновременно преобразовать элементы и отфильтровать ненужные. Например, получить квадраты чисел или оставить только чётные. Это часто заменяет несколько строк с циклом и `append`. Главное — не делать выражение слишком сложным: если много условий, лучше обычный `for`. Практика: создай список квадратов 1..20, затем из строки оставь только буквы через `isalpha()`. Сравни с вариантом на цикле и выбери более читаемый стиль.",
    "code": "nums = list(range(1, 11))\nsquares = [n*n for n in nums]\nevens = [n for n in nums if n % 2 == 0]\nprint(squares)\nprint(evens)",
    "tasks": [
      "Квадраты 1..20",
      "Оставь только буквы в строке (isalpha)"
    ]
  },
  {
    "id": 25,
    "lang": "Python",
    "level": "Intermediate",
    "title": "split/join",
    "tags": [
      "split",
      "join"
    ],
    "explanation": "`split()` разбивает строку на список частей, а `join()` собирает список строк обратно в одну строку через выбранный разделитель. Это часто используется для обработки текста: посчитать слова, построить “slug” для URL, заменить пробелы, склеить путь или список тегов. `split()` без аргументов корректно обрабатывает несколько пробелов подряд. `join` работает только со строками, поэтому числа нужно приводить через `str()`. Практика: возьми предложение, сделай список слов, посчитай количество, а затем собери обратно через `-`. Добавь очистку `strip()` и `lower()` и сравни результат.",
    "code": "text = \"python is fun\"\nwords = text.split()\nprint(words)\nprint(\"-\".join(words))",
    "tasks": [
      "Посчитай количество слов.",
      "Собери строку из списка слов."
    ]
  },
  {
    "id": 26,
    "lang": "Python",
    "level": "Intermediate",
    "title": "Файлы: чтение/запись",
    "tags": [
      "files",
      "io"
    ],
    "explanation": "Файлы позволяют сохранять данные и читать их позже: заметки, результаты, логи. В Python используйте `with open(...) as f:` — это безопасно, файл закрывается автоматически. Режимы: `r` чтение, `w` запись с перезаписью, `a` добавление в конец. Для русского текста указывай `encoding=\"utf-8\"`. Читать можно целиком (`read()`), построчно (`for line in f`) или через `readlines()`. Практика: запиши несколько строк в файл, затем прочитай и посчитай строки. Попробуй записать данные дважды в режиме `a` и убедись, что файл увеличился, а не перезаписался.",
    "code": "with open(\"notes.txt\",\"w\",encoding=\"utf-8\") as f:\n    f.write(\"Строка 1\\nСтрока 2\\n\")\n\nwith open(\"notes.txt\",\"r\",encoding=\"utf-8\") as f:\n    print(f.read())",
    "tasks": [
      "Запиши 5 строк.",
      "Прочитай и посчитай строки."
    ]
  },
  {
    "id": 27,
    "lang": "Python",
    "level": "Intermediate",
    "title": "Исключения try/except",
    "tags": [
      "exceptions"
    ],
    "explanation": "Ошибки случаются постоянно: неверный ввод, деление на ноль, отсутствующий файл. `try/except` позволяет обработать такие ситуации и не “ронять” программу. Лучше ловить конкретные ошибки (`ValueError`, `ZeroDivisionError`, `FileNotFoundError`), чтобы не скрывать другие проблемы. Часто `try/except` сочетают с циклом: спрашиваем ввод, пытаемся преобразовать, при ошибке просим повторить. Это делает программу дружелюбной к пользователю. Практика: сделай безопасный ввод числа с повтором, затем обработай деление на ноль. После этого попробуй открыть несуществующий файл и выведи понятное сообщение вместо traceback.",
    "code": "try:\n    x = int(input(\"x: \"))\n    print(10 / x)\nexcept ValueError:\n    print(\"Нужно целое число\")\nexcept ZeroDivisionError:\n    print(\"На ноль нельзя\")",
    "tasks": [
      "Повторяй ввод, пока не введут число.",
      "Поймай FileNotFoundError."
    ]
  },
  {
    "id": 28,
    "lang": "Python",
    "level": "Intermediate",
    "title": "Модули и stdlib",
    "tags": [
      "modules",
      "import"
    ],
    "explanation": "Модули позволяют подключать готовые функции и поддерживать порядок в коде. Импорт: `import math`, `import random`, `from datetime import datetime`. Стандартная библиотека Python очень богата и закрывает множество задач без внешних пакетов: математика, время, JSON, файлы, пути, регулярки. Когда проект растёт, создавай свои модули (например, `utils.py`) и импортируй функции оттуда. Это делает код аккуратным и повторно используемым. Практика: сгенерируй 5 случайных чисел через `random`, затем используй `math.sqrt` и `round`. После этого вынеси одну функцию в `utils.py` и импортируй её в `main.py`.",
    "code": "import math, random\nprint(math.sqrt(81))\nprint(random.randint(1, 10))",
    "tasks": [
      "Сгенерируй 5 чисел 1..100.",
      "Округли 3.14159 до 3 знаков."
    ]
  },
  {
    "id": 29,
    "lang": "Python",
    "level": "Intermediate",
    "title": "lambda + map/filter",
    "tags": [
      "lambda",
      "map",
      "filter"
    ],
    "explanation": "`lambda` — короткая функция без имени. В паре с `map` и `filter` она помогает быстро преобразовывать и фильтровать коллекции. `map(fn, xs)` применяет `fn` к каждому элементу, `filter(fn, xs)` оставляет только те элементы, где `fn` вернула `True`. Но не забывай про читаемость: во многих случаях списковое включение понятнее. Практика: преобразуй температуры C→F через `map`, затем оставь только чётные числа через `filter`. Сравни оба варианта с comprehension, чтобы понять, какой стиль тебе удобнее.",
    "code": "nums = [1,2,3,4,5]\nsquares = list(map(lambda x: x*x, nums))\nevens = list(filter(lambda x: x%2==0, nums))\nprint(squares, evens)",
    "tasks": [
      "Оставь >10 через filter.",
      "C→F через map."
    ]
  },
  {
    "id": 30,
    "lang": "Python",
    "level": "Intermediate",
    "title": "sorted(key=...)",
    "tags": [
      "sorting",
      "key"
    ],
    "explanation": "Когда нужно сортировать не “просто по значению”, используется параметр `key`. Он задаёт функцию, которая вычисляет признак сортировки для каждого элемента. Примеры: `key=len` сортирует строки по длине, `key=lambda u: u[\"age\"]` сортирует словари по возрасту, `key=lambda s: s[-1]` — по последней букве. Это полезно для рейтингов, каталогов товаров, статистики. Следи, чтобы `key` возвращал сравнимые значения. Практика: отсортируй слова по длине и по последней букве, затем сделай список пользователей и отсортируй по возрасту, а при равенстве — по имени. Так ты почувствуешь, как гибко управляется порядок.",
    "code": "words = [\"python\",\"go\",\"javascript\",\"c\"]\nprint(sorted(words, key=len))\nprint(sorted(words, key=lambda s: s[-1]))",
    "tasks": [
      "Отсортируй пользователей по age.",
      "Отсортируй товары по price."
    ]
  },
  {
    "id": 31,
    "lang": "Python",
    "level": "Intermediate",
    "title": "JSON: loads/dumps",
    "tags": [
      "json"
    ],
    "explanation": "JSON — популярный формат обмена данными между программами и сервисами. В Python модуль `json` умеет превращать словари и списки в JSON‑строку (`json.dumps`) и обратно (`json.loads`). Для файлов используют `json.dump` и `json.load`. Полезные параметры: `ensure_ascii=False`, чтобы русские буквы не превращались в `\\u...`, и `indent=2`, чтобы файл был читаемым. JSON удобен как простая “база” без сервера: хранить задачи, настройки, результаты викторины. Практика: сохрани структуру в `tasks.json`, затем загрузись обратно и выведи данные. Попробуй изменить JSON вручную и снова прочитать — так ты лучше поймёшь формат и типичные ошибки (запятые, кавычки).",
    "code": "import json\ndata = {\"name\":\"Amina\",\"skills\":[\"python\",\"sql\"]}\ns = json.dumps(data, ensure_ascii=False, indent=2)\nprint(s)\nobj = json.loads(s)\nprint(obj[\"skills\"])",
    "tasks": [
      "Сохрани tasks.json и прочитай обратно.",
      "Сделай красивый вывод indent=2."
    ]
  },
  {
    "id": 32,
    "lang": "Python",
    "level": "Advanced",
    "title": "ООП: class и __init__",
    "tags": [
      "oop",
      "class"
    ],
    "explanation": "Класс в Python описывает объект с данными и поведением. Метод `__init__` вызывается при создании объекта и обычно сохраняет входные значения в поля `self.*`. Методы класса работают с этими полями и помогают спрятать детали реализации. ООП удобно, когда у тебя много похожих сущностей: пользователи, товары, заказы, задачи. Вместо разрозненных словарей появляется структура с понятными методами, например `product.total(qty)`. Важно не усложнять: начинай с маленьких классов и добавляй методы по мере необходимости. Практика: создай класс `User` и метод `info()`, затем сделай класс `Product` и посчитай сумму заказа из нескольких объектов. Сравни это с вариантом на словарях.",
    "code": "class User:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n    def info(self):\n        return f\"{self.name}, {self.age}\"\n\nu = User(\"Ali\", 17)\nprint(u.info())",
    "tasks": [
      "Product(name, price) + total(qty).",
      "Список продуктов → сумма заказа."
    ]
  },
  {
    "id": 33,
    "lang": "Python",
    "level": "Advanced",
    "title": "Наследование",
    "tags": [
      "inheritance",
      "oop"
    ],
    "explanation": "Наследование позволяет создать новый класс на основе существующего. Дочерний класс получает методы и поля родителя и может добавлять свои или переопределять существующие. Это полезно, когда есть общая логика: `Animal` → `Cat`, `Dog`, или `Vehicle` → `Car`. Если метод переопределён, будет использоваться версия дочернего класса. При необходимости можно вызвать поведение родителя через `super()`. Главное — не злоупотреблять наследованием: иногда композиция проще и понятнее. Практика: сделай базовый класс с методом `speak()`, затем переопредели его в дочернем. Попробуй добавить общий конструктор в родителя и вызвать `super().__init__()` в дочернем классе.",
    "code": "class Animal:\n    def speak(self):\n        return \"...\"\n\nclass Cat(Animal):\n    def speak(self):\n        return \"meow\"\n\nprint(Cat().speak())",
    "tasks": [
      "Vehicle → Car",
      "Покажи super() на примере."
    ]
  },
  {
    "id": 34,
    "lang": "Python",
    "level": "Advanced",
    "title": "@property",
    "tags": [
      "property",
      "oop"
    ],
    "explanation": "`@property` делает удобный интерфейс: к методу можно обращаться как к полю. Это особенно полезно, когда нужно проверять значения при чтении или записи. Обычно реальное значение хранят во внутреннем атрибуте (например, `_balance`), а через `@property` дают безопасный доступ `balance`. Через `@balance.setter` можно запретить неправильные значения: отрицательный баланс, оценку вне диапазона, пустое имя. Такой подход улучшает качество кода: объект сам следит за корректностью своих данных. Практика: сделай класс `Account` с балансом и запрети отрицательные значения. Затем попробуй установить неправильное значение и обработай ошибку через `try/except`, чтобы показать пользователю понятное сообщение.",
    "code": "class Account:\n    def __init__(self, balance=0):\n        self._balance = balance\n\n    @property\n    def balance(self):\n        return self._balance\n\n    @balance.setter\n    def balance(self, value):\n        if value < 0:\n            raise ValueError(\"Баланс не может быть отрицательным\")\n        self._balance = value\n\na = Account(100)\na.balance = 150\nprint(a.balance)",
    "tasks": [
      "Student.grade 0..100 через property.",
      "Поймай ошибку при -5."
    ]
  },
  {
    "id": 35,
    "lang": "Python",
    "level": "Advanced",
    "title": "Декораторы",
    "tags": [
      "decorators"
    ],
    "explanation": "Декоратор — это функция, которая принимает другую функцию и возвращает новую, “обёрнутую”. Так можно добавить поведение без изменения исходной функции: логирование, измерение времени, проверку аргументов, кеширование. Внутри обычно создают `wrapper(*args, **kwargs)`, вызывают оригинальную функцию и возвращают результат. Важно не потерять аргументы и возвращаемое значение, иначе обёртка сломает интерфейс. Декораторы часто встречаются во Flask/Django, тестах и инструментах. Практика: сделай декоратор `timer`, который измеряет время выполнения. Применяй его к двум функциям и сравни результаты. Затем добавь декоратор “start/end” и посмотри, как удобно добавлять одинаковые действия ко многим функциям.",
    "code": "import time\ndef timer(fn):\n    def wrapper(*args, **kwargs):\n        t0 = time.time()\n        res = fn(*args, **kwargs)\n        print(\"time:\", round(time.time()-t0, 4))\n        return res\n    return wrapper\n\n@timer\ndef work():\n    s = 0\n    for i in range(200000):\n        s += i\n    return s\n\nwork()",
    "tasks": [
      "Декоратор start/end.",
      "Применить к greet()."
    ]
  },
  {
    "id": 36,
    "lang": "Python",
    "level": "Advanced",
    "title": "yield: генераторы",
    "tags": [
      "generators",
      "yield"
    ],
    "explanation": "Генераторы позволяют получать значения по одному, не создавая весь список сразу. Это экономит память и подходит для больших данных: чтение файлов, обработка потоков, длинные последовательности. В генераторе используется `yield`, который отдаёт значение и приостанавливает функцию, сохраняя её состояние. При следующем обращении генератор продолжает с того же места. Генераторы удобно использовать в `for`, а также комбинировать с `sum`, `any`, `all`. Практика: сделай генератор квадратов, затем генератор обратного отсчёта. Попробуй реализовать генератор, который читает файл построчно и выдаёт строки по одной — это реальный сценарий “ленивой” обработки данных.",
    "code": "def squares(n):\n    for i in range(1, n+1):\n        yield i*i\n\nfor x in squares(5):\n    print(x)",
    "tasks": [
      "countdown(n) генератор.",
      "Генератор чтения файла построчно."
    ]
  },
  {
    "id": 37,
    "lang": "Python",
    "level": "Intermediate",
    "title": "datetime: даты",
    "tags": [
      "datetime"
    ],
    "explanation": "Модуль `datetime` помогает работать с датой и временем: получить текущее время, добавить дни, сравнить даты, красиво отформатировать вывод. `datetime.now()` возвращает текущий момент, `timedelta(days=7)` позволяет сделать сдвиг. Для вывода в нужном виде применяют `strftime` (например, `\"%Y-%m-%d\"`). Эти навыки нужны для отчётов, дедлайнов, расписаний и логов. Важно понимать, что `date` хранит только дату, а `datetime` — дату и время. Практика: вычисли дату через 7 и через 30 дней, распарсь строку `2026-03-01` и выведи её в нескольких форматах. Затем сравни две даты и выведи, какая раньше.",
    "code": "from datetime import datetime, timedelta\nnow = datetime.now()\nprint(now.strftime(\"%Y-%m-%d %H:%M\"))\nprint((now + timedelta(days=7)).date())",
    "tasks": [
      "Дата через 30 дней.",
      "Распарси '2026-03-01'."
    ]
  },
  {
    "id": 38,
    "lang": "Python",
    "level": "Advanced",
    "title": "re: регулярки",
    "tags": [
      "regex",
      "re"
    ],
    "explanation": "Регулярные выражения (`re`) помогают находить и извлекать данные по шаблону: email, числа, телефоны, отдельные части строк. Начинать лучше с `re.findall` (все совпадения) и `re.search` (первое совпадение). Регулярки мощные, но могут стать сложными, поэтому делай шаблон простым и тестируй на примерах. Частая задача: найти все числа в тексте или проверить, что пароль содержит цифру. Помни про экранирование и “сырые” строки `r\"...\"`. Практика: сделай шаблон для email и проверь его на нескольких строках. Потом извлеки все числа из текста и попробуй собрать их в список целых чисел.",
    "code": "import re\ntext = \"mail: test@mail.com, num: +99890-123-45-67\"\nprint(re.findall(r\"[\\w.]+@[\\w.]+\", text))\nprint(re.findall(r\"\\d+\", text))",
    "tasks": [
      "Найди все числа.",
      "Проверь, что пароль содержит цифру."
    ]
  },
  {
    "id": 39,
    "lang": "Python",
    "level": "Intermediate",
    "title": "pathlib",
    "tags": [
      "pathlib"
    ],
    "explanation": "`pathlib.Path` — удобный и современный способ работать с путями, файлами и папками. Он учитывает особенности разных ОС и делает код аккуратнее, чем склейка строк. Через `Path` можно перечислять файлы (`iterdir()`), проверять существование (`exists()`), создавать папки (`mkdir()`), фильтровать по расширению и строить пути через `/`. Это полезно в автоматизации и обработке данных: пройти по директории, найти все `.txt`, записать результат в отдельный файл. Практика: создай папку `data`, если её нет, выведи список файлов, затем собери путь `data / \"out.txt\"` и запиши туда текст. Попробуй вывести абсолютный путь через `.resolve()`.",
    "code": "from pathlib import Path\np = Path(\".\")\nprint([x.name for x in p.iterdir() if x.is_file()])",
    "tasks": [
      "Создай папку data, если нет.",
      "Выведи все .txt файлы."
    ]
  },
  {
    "id": 40,
    "lang": "Python",
    "level": "Intermediate",
    "title": "assert и базовые тесты",
    "tags": [
      "testing",
      "assert"
    ],
    "explanation": "`assert` — простой способ быстро проверить, что функция работает правильно. Если утверждение ложно, Python выбросит `AssertionError`. Это удобно для учебных задач: написал функцию — сразу добавил несколько тестов с ожидаемыми результатами. Хорошие тесты включают граничные случаи: ноль, отрицательные значения, пустые строки, большие числа. Конечно, для больших проектов используют pytest, но `assert` — отличная база. Практика: напиши `factorial(n)` и добавь 5 проверок `assert`. Затем напиши `clamp(x, lo, hi)` и протестируй случаи, когда `x` меньше `lo`, больше `hi` и внутри диапазона. Так ты научишься думать о корректности кода как разработчик.",
    "code": "def is_even(n): return n % 2 == 0\nassert is_even(2) is True\nassert is_even(3) is False\nprint(\"OK\")",
    "tasks": [
      "Тесты для clamp(x,lo,hi).",
      "Тесты для factorial."
    ]
  },
  {
    "id": 41,
    "lang": "Python",
    "level": "Intermediate",
    "title": "Данные: список словарей",
    "tags": [
      "data",
      "dict",
      "list"
    ],
    "explanation": "Список словарей — популярный способ хранить данные без базы. Каждый словарь описывает одну запись (товар, пользователь, задача), а список хранит множество записей. Такой формат легко фильтровать, сортировать и суммировать: общий чек — это сумма `price * qty`, самый дорогой товар — `max(..., key=...)`. Этот же формат удобно сохранять в JSON. Практика: создай 3–5 товаров, посчитай сумму заказа, отфильтруй товары дешевле заданной цены и отсортируй по цене. Добавь поле `total` в каждый товар и выведи красивый чек через f‑строки. Это типичный пример того, как данные превращаются в полезный результат.",
    "code": "products = [\n  {\"name\":\"Keyboard\",\"price\":25,\"qty\":2},\n  {\"name\":\"Mouse\",\"price\":12,\"qty\":5},\n]\ntotal = sum(p[\"price\"]*p[\"qty\"] for p in products)\nprint(total)",
    "tasks": [
      "Найди самый дорогой товар.",
      "Отфильтруй дешевле 20."
    ]
  },
  {
    "id": 42,
    "lang": "Python",
    "level": "Beginner",
    "title": "Линейный поиск",
    "tags": [
      "algorithms",
      "search"
    ],
    "explanation": "Линейный поиск — базовый алгоритм: мы идём по списку и проверяем каждый элемент. Он работает на любых данных, даже если список не отсортирован. В худшем случае придётся проверить все элементы, поэтому сложность O(n). На практике линейный поиск часто достаточно быстрый для небольших списков. Чтобы найти индекс, удобно использовать `enumerate`, а чтобы остановиться на первом совпадении — `break`. Практика: найди индекс первого отрицательного числа в списке, затем проверь, есть ли слово `python` в списке строк (учитывая регистр). Сделай два варианта: остановка на первом совпадении и подсчёт количества совпадений — так ты увидишь разницу в логике.",
    "code": "nums = [4, 8, 15, 16, 23, 42]\ntarget = 16\npos = -1\nfor i, x in enumerate(nums):\n    if x == target:\n        pos = i\n        break\nprint(pos)",
    "tasks": [
      "Индекс первого отрицательного.",
      "Есть ли 'python' в списке слов?"
    ]
  },
  {
    "id": 43,
    "lang": "Python",
    "level": "Advanced",
    "title": "Бинарный поиск",
    "tags": [
      "binary search",
      "algorithms"
    ],
    "explanation": "Бинарный поиск работает только на **отсортированном** списке. Идея: сравнить цель с серединой и каждый раз отбрасывать половину диапазона. Поэтому сложность O(log n): очень быстро на больших данных. Важно аккуратно обновлять границы `lo` и `hi`, чтобы цикл завершался. Бинарный поиск нужен в задачах на индексы, диапазоны, поиск по массиву и часто встречается на собеседованиях. Практика: отсортируй список и найди элемент. Затем измени алгоритм так, чтобы он возвращал позицию вставки, если элемента нет (например, где его вставить, чтобы порядок сохранился). Это полезно для поддержания отсортированного списка и подсказок поиска.",
    "code": "def bin_search(a, x):\n    lo, hi = 0, len(a)-1\n    while lo <= hi:\n        mid = (lo+hi)//2\n        if a[mid] == x: return mid\n        if a[mid] < x: lo = mid+1\n        else: hi = mid-1\n    return -1\n\narr = [1,3,5,7,9,11]\nprint(bin_search(arr, 7))",
    "tasks": [
      "Отсортируй и найди элемент.",
      "Верни место вставки если нет."
    ]
  },
  {
    "id": 44,
    "lang": "Python",
    "level": "Intermediate",
    "title": "Big-O: сложность",
    "tags": [
      "big-o"
    ],
    "explanation": "Big‑O показывает, как растёт время работы алгоритма при увеличении объёма данных. Один цикл по n элементам — обычно O(n), два вложенных цикла — O(n²), а бинарный поиск — O(log n). Это не точные секунды, а оценка роста: при больших данных разница становится огромной. Понимание сложности помогает выбирать правильные структуры данных и алгоритмы: например, вместо поиска в списке использовать `set` для быстрых проверок `in`. Практика: сравни подход “вложенный цикл для поиска общих элементов” и подход через множества (пересечение). Затем увеличь размеры данных и подумай, почему второй вариант масштабируется лучше.",
    "code": "n = 5\ncnt = 0\nfor i in range(n):\n    for j in range(n):\n        cnt += 1\nprint(cnt)",
    "tasks": [
      "Сложность двух вложенных циклов?",
      "Почему O(log n) быстрее O(n)?"
    ]
  },
  {
    "id": 45,
    "lang": "Python",
    "level": "Intermediate",
    "title": "HTTP API: requests (идея)",
    "tags": [
      "http",
      "api",
      "requests"
    ],
    "explanation": "HTTP API позволяет получать данные от сервисов через интернет. Библиотека `requests` делает это просто: `get` возвращает ответ, где есть `status_code`, заголовки и тело. Важно понимать коды: 200 — успех, 404 — не найдено, 500 — ошибка сервера. Часто ответы приходят в JSON, который можно распарсить и использовать в программе. Умение работать с API пригодится для ботов, автоматизации и интеграций. Практика: сделай запрос к `https://api.github.com`, выведи статус и часть ответа. Затем добавь обработку ошибок: если статус не 200, выведи сообщение и не пытайся парсить данные. Это формирует правильную привычку писать надёжный код.",
    "code": "# pip install requests\nimport requests\nr = requests.get(\"https://api.github.com\")\nprint(r.status_code)\nprint(r.headers.get(\"content-type\"))",
    "tasks": [
      "Сделай GET к любому API.",
      "Выведи первые 200 символов."
    ]
  },
  {
    "id": 46,
    "lang": "Python",
    "level": "Intermediate",
    "title": "HTML парсинг: BeautifulSoup (идея)",
    "tags": [
      "parsing",
      "bs4"
    ],
    "explanation": "BeautifulSoup помогает разбирать HTML и доставать нужные элементы: заголовки, ссылки, текст. Обычно сначала страницу скачивают через `requests`, потом создают `BeautifulSoup(html, \"html.parser\")` и ищут теги (`title`, `a`, `h1` и т.д.). Это полезно для учебных проектов и анализа страниц. Но важно соблюдать правила сайтов: не делай частые запросы, уважай `robots.txt`, по возможности используй официальные API. Практика: скачай `example.com`, выведи `title`, посчитай количество ссылок `<a>` и попробуй вывести их `href`. Затем добавь обработку ошибок сети и пустых результатов, чтобы скрипт был стабильным.",
    "code": "# pip install beautifulsoup4 requests\nimport requests\nfrom bs4 import BeautifulSoup\n\nhtml = requests.get(\"https://example.com\").text\nsoup = BeautifulSoup(html, \"html.parser\")\nprint(soup.title.text)",
    "tasks": [
      "Выведи title example.com.",
      "Посчитай количество ссылок <a>."
    ]
  },
  {
    "id": 47,
    "lang": "Python",
    "level": "Advanced",
    "title": "Flask: минимальный сервер",
    "tags": [
      "flask",
      "web"
    ],
    "explanation": "Flask позволяет быстро создать веб‑сервер и обработчики маршрутов: `@app.get(\"/\")` — главная страница, `@app.get(\"/hello/<name>\")` — маршрут с параметром. Это помогает понять, как работают сайты “на сервере”: браузер отправляет запрос, сервер выполняет код и возвращает ответ. Важно: GitHub Pages запускает только статические файлы, поэтому Flask — отдельная тема для будущего хостинга. Но для обучения Flask очень полезен: ты увидишь реальный цикл веб‑приложения. Практика: добавь `/about`, сделай маршрут, который возвращает JSON, и попробуй открыть его в браузере. Затем добавь простую проверку параметров и обработку ошибок.",
    "code": "# pip install flask\nfrom flask import Flask\napp = Flask(__name__)\n\n@app.get(\"/\")\ndef home():\n    return \"Hello from Flask!\"\n\nif __name__ == \"__main__\":\n    app.run(debug=True)",
    "tasks": [
      "Добавь /about.",
      "Сделай /hello/<name>."
    ]
  },
  {
    "id": 48,
    "lang": "Python",
    "level": "Intermediate",
    "title": "Мини‑проект: трекер задач",
    "tags": [
      "project",
      "cli",
      "json"
    ],
    "explanation": "Проект “трекер задач” закрепляет списки, словари, функции, циклы и работу с файлами. Храни задачи в структуре вроде `[{text, done}]`, показывай список, добавляй новые и отмечай выполненные. Чтобы задачи не пропадали после закрытия программы, сохраняй их в JSON и загружай при старте. Такой проект учит делать меню команд и разделять код на функции: `add_task`, `list_tasks`, `toggle_done`, `save`, `load`. Практика: добавь нумерацию и проверку ввода (не разрешай пустой текст). Сделай красивый вывод статуса (`[ ]` и `[x]`) и сортировку: сначала невыполненные, потом выполненные. Это уже будет полезная утилита для себя.",
    "code": "import json\ntasks = [{\"text\":\"Изучить списки\",\"done\":False}]\n\ndef save(path=\"tasks.json\"):\n    with open(path,\"w\",encoding=\"utf-8\") as f:\n        json.dump(tasks, f, ensure_ascii=False, indent=2)\n\ntasks[0][\"done\"] = True\nsave()\nprint(tasks)",
    "tasks": [
      "Добавь load() из файла.",
      "Сделай меню (показать/добавить/отметить/сохранить)."
    ]
  },
  {
    "id": 49,
    "lang": "Python",
    "level": "Beginner",
    "title": "Мини‑проект: викторина",
    "tags": [
      "project",
      "quiz"
    ],
    "explanation": "Викторина — простой проект, который хорошо тренирует условия и циклы. Храни вопросы в списке словарей, задавай их по очереди и сравнивай ответ пользователя с правильным. Чтобы сравнение было честным, используй `strip()` и `lower()`. По итогам выведи счёт и процент правильных ответов. Проект легко расширяется: случайный порядок вопросов, категории, подсказки, хранение результатов в файле. Практика: добавь 15 вопросов по Python, сделай вывод неправильных ответов (покажи правильный). Затем сохрани лучший результат в JSON, чтобы у тебя появился “рекорд”. Так ты одновременно закрепишь работу со строками и файлами.",
    "code": "questions = [\n  {\"q\":\"Сколько будет 2+2?\", \"a\":\"4\"},\n  {\"q\":\"Какой тип у 'hello'?\", \"a\":\"str\"},\n]\nscore = 0\nfor item in questions:\n    ans = input(item[\"q\"] + \" \")\n    if ans.strip().lower() == item[\"a\"]:\n        score += 1\nprint(\"Результат:\", score, \"/\", len(questions))",
    "tasks": [
      "Добавь 10 вопросов.",
      "Сделай подсчёт процентов."
    ]
  },
  {
    "id": 50,
    "lang": "Python",
    "level": "Intermediate",
    "title": "Срезы списков и копирование",
    "tags": [
      "list",
      "copy"
    ],
    "explanation": "Срезы списка (`a[start:end]`) позволяют взять часть данных, а `a[:]` — сделать копию. Важно различать ссылку и копию: `b = a` означает, что обе переменные указывают на один и тот же список, и изменения будут общими. Независимая копия создаётся через `a[:]` или `list(a)`. Но если список вложенный, поверхностная копия не копирует вложенные элементы — они остаются общими. Тогда нужен `copy.deepcopy`. Практика: сделай список, скопируй его двумя способами и сравни. Затем сделай вложенный список (например, матрица 2×2), измени вложенный элемент и увидишь, почему иногда нужна глубокая копия.",
    "code": "a = [1,2,3]\nb = a\nc = a[:]\na.append(4)\nprint(b)  # изменился\nprint(c)  # нет",
    "tasks": [
      "Сделай копию и проверь независимость.",
      "Попробуй со вложенным списком."
    ]
  },
  {
    "id": 51,
    "lang": "HTML",
    "level": "Beginner",
    "title": "HTML: структура документа",
    "tags": [
      "html",
      "doctype",
      "head",
      "body"
    ],
    "explanation": "HTML задаёт структуру страницы: из каких блоков она состоит и как браузер должен её понимать. Базовый каркас включает `<!doctype html>`, тег `<html>`, секции `<head>` и `<body>`. В `head` лежат метаданные: заголовок вкладки (`<title>`), подключение CSS/JS, описание страницы для поиска. В `body` — видимый контент. Важно соблюдать вложенность тегов и закрывать их, чтобы разметка не “ломалась”. Практика: собери минимальную страницу, добавь заголовок и несколько блоков, затем открой в браузере и посмотри, как изменения в HTML сразу меняют отображение. Такой каркас — основа для любых сайтов, включая твой учебный проект.",
    "code": "<!doctype html>\n<html lang=\"ru\">\n<head>\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n  <title>Мой сайт</title>\n</head>\n<body>\n  <h1>Привет!</h1>\n</body>\n</html>",
    "tasks": [
      "Сделай страницу с h1 и p.",
      "Добавь favicon через <link rel='icon'>."
    ]
  },
  {
    "id": 52,
    "lang": "HTML",
    "level": "Beginner",
    "title": "HTML: текст, списки, ссылки",
    "tags": [
      "a",
      "ul",
      "ol",
      "p"
    ],
    "explanation": "Текстовые теги помогают правильно оформить контент: заголовки `<h1>…<h6>`, абзацы `<p>`, выделение `<strong>` и `<em>`. Списки бывают маркированные (`<ul>`) и нумерованные (`<ol>`), а элементы списка — `<li>`. Ссылки создаются через `<a href=\"...\">`, и важно указывать корректный URL или относительный путь. Для удобства пользователя можно добавлять `target=\"_blank\"` (открывать в новой вкладке), но делать это стоит осознанно. Практика: сделай страницу “О курсе”: заголовок, 2 абзаца, список тем и ссылки на разделы. Так ты научишься собирать контент структурно, а не просто “текстом”.",
    "code": "<h2>Список дел</h2>\n<ul>\n  <li>Учить HTML</li>\n  <li>Учить CSS</li>\n</ul>\n<a href=\"https://developer.mozilla.org/\" target=\"_blank\">MDN</a>",
    "tasks": [
      "Сделай меню навигации из ссылок.",
      "Сделай нумерованный список из 5 пунктов."
    ]
  },
  {
    "id": 53,
    "lang": "HTML",
    "level": "Beginner",
    "title": "HTML: изображения и alt",
    "tags": [
      "img",
      "alt",
      "paths"
    ],
    "explanation": "Изображения добавляют через тег `<img src=\"...\" alt=\"...\">`. Атрибут `src` указывает путь к файлу или URL, а `alt` — текстовое описание, которое видно, если картинка не загрузилась, и которое помогает доступности (screen reader) и SEO. Размеры лучше контролировать через CSS, но иногда удобно задать `width`/`height`, чтобы избежать “прыжков” макета. Практика: добавь на страницу 2–3 картинки, одну сломай специально (неверный путь) и посмотри, как работает `alt`. Затем сделай галерею с подписями — это часто используется на лендингах и в статьях.",
    "code": "<img src=\"img/logo.png\" alt=\"Логотип\" width=\"120\">",
    "tasks": [
      "Добавь изображение и подпись.",
      "Сделай ссылку-картинку (img внутри a)."
    ]
  },
  {
    "id": 54,
    "lang": "HTML",
    "level": "Intermediate",
    "title": "HTML: формы",
    "tags": [
      "forms",
      "input",
      "label"
    ],
    "explanation": "Формы позволяют пользователю отправлять данные: поиск, обратная связь, логин, фильтры. Основные элементы: `<form>`, поля `<input>`, многострочный `<textarea>`, выпадающий список `<select>`, кнопка `<button>`. Атрибуты `name`, `placeholder`, `required`, `type=\"email\"/\"password\"` помогают браузеру валидировать ввод и улучшают UX. Даже если сайт статический, формы полезны для интерфейса фильтрации и поиска (как у твоего сайта с уроками). Практика: сделай форму “поиск урока” и форму “обратная связь”. Проверь, как работает `required` и разные типы `input` в браузере.",
    "code": "<form>\n  <label for=\"email\">Email</label>\n  <input id=\"email\" type=\"email\" placeholder=\"name@mail.com\">\n  <button type=\"submit\">Отправить</button>\n</form>",
    "tasks": [
      "Сделай форму: имя, возраст, кнопка.",
      "Добавь select со списком городов."
    ]
  },
  {
    "id": 55,
    "lang": "HTML",
    "level": "Intermediate",
    "title": "HTML: семантика",
    "tags": [
      "semantic",
      "seo"
    ],
    "explanation": "Семантические теги делают страницу понятной не только человеку, но и браузеру, поисковику и экранным читателям. Вместо безликих `<div>` стоит использовать `<header>`, `<nav>`, `<main>`, `<section>`, `<article>`, `<footer>`. Это улучшает структуру, помогает SEO и делает код поддерживаемым. Семантика особенно важна для контентных сайтов: уроки, статьи, справочники. Практика: возьми страницу и замени часть `div` на семантические теги. Затем проверь, что структура логична: один `<h1>` на страницу, разделы оформлены через `<section>`, а карточки уроков можно считать `<article>`. Такой подход делает сайт “профессиональнее” даже без сложного дизайна.",
    "code": "<header>Шапка</header>\n<nav>Меню</nav>\n<main>\n  <article>Статья</article>\n</main>\n<footer>Подвал</footer>",
    "tasks": [
      "Переоформи страницу с семантикой.",
      "Добавь aria-label для nav."
    ]
  },
  {
    "id": 56,
    "lang": "CSS",
    "level": "Beginner",
    "title": "CSS: подключение и селекторы",
    "tags": [
      "css",
      "selectors"
    ],
    "explanation": "CSS отвечает за внешний вид: цвета, размеры, отступы, шрифты и расположение блоков. Подключить CSS можно через `<link rel=\"stylesheet\" href=\"styles.css\">` в `<head>`. Селекторы определяют, к каким элементам применяются правила: по тегу (`p`), классу (`.card`), id (`#header`), вложенности (`.menu a`). Чем точнее селектор, тем выше его специфичность — это влияет на то, какое правило победит. Практика: создай несколько блоков с классами и сделай для них разные стили. Затем попробуй переопределить стиль более точным селектором и посмотри, как меняется результат. Понимание селекторов — база для любого дизайна.",
    "code": "body{font-family:system-ui;}\n.box{padding:12px;border:1px solid #ccc;}\n#main{max-width:900px;margin:0 auto;}",
    "tasks": [
      "Сделай .card и применяй к блокам.",
      "Стили для h1 и p."
    ]
  },
  {
    "id": 57,
    "lang": "CSS",
    "level": "Beginner",
    "title": "CSS: box model",
    "tags": [
      "box-model",
      "margin",
      "padding"
    ],
    "explanation": "Box model объясняет, как браузер рассчитывает размер элемента. У каждого блока есть `content` (контент), `padding` (внутренние отступы), `border` (рамка) и `margin` (внешние отступы). Частая проблема новичков: ширина “плывёт”, потому что `padding` добавляется к `width`. Решение — `box-sizing: border-box;`, тогда `width` включает padding и border. Практика: сделай карточку с фиксированной шириной и разными `padding/margin`, добавь рамку и посмотри, как меняется размер. Затем включи `border-box` и сравни. Это знание помогает стабильно верстать сетки, карточки и формы.",
    "code": "div{margin:16px;padding:12px;border:2px solid #444;border-radius:12px;}",
    "tasks": [
      "Карточка с padding 16 и radius 16.",
      "Отступ между карточками через margin."
    ]
  },
  {
    "id": 58,
    "lang": "CSS",
    "level": "Intermediate",
    "title": "CSS: Flexbox",
    "tags": [
      "flex",
      "layout"
    ],
    "explanation": "Flexbox — удобный способ выравнивать элементы в строку или колонку и распределять пространство. Основные свойства: `display: flex`, `justify-content` (распределение по главной оси), `align-items` (выравнивание по поперечной), `gap` (расстояние между элементами), `flex-wrap` (перенос). Flexbox идеально подходит для шапки сайта, меню, карточек в ряд и кнопок. Практика: сделай ряд карточек уроков, выровняй их по центру и добавь перенос на новую строку. Затем попробуй разные `justify-content` и увидишь, как быстро можно менять внешний вид без сложных расчётов. Flexbox сильно ускоряет верстку интерфейсов.",
    "code": ".row{display:flex;gap:12px;justify-content:space-between;align-items:center;flex-wrap:wrap;}",
    "tasks": [
      "Сделай две колонки 70/30.",
      "Сделай ряд карточек с переносом."
    ]
  },
  {
    "id": 59,
    "lang": "CSS",
    "level": "Intermediate",
    "title": "CSS: Grid",
    "tags": [
      "grid",
      "layout"
    ],
    "explanation": "CSS Grid — инструмент для создания двумерных сеток (строки и колонки одновременно). Он отлично подходит для сложных раскладок: галереи, дашборды, страницы с сайдбаром. Основные идеи: `display: grid`, `grid-template-columns`, `grid-template-rows`, `gap`. Можно задавать колонки как `repeat(3, 1fr)` и получать адаптивную сетку. Grid позволяет элементам занимать несколько колонок или строк, что сложно делать на Flexbox. Практика: сделай сетку карточек 3×N, затем добавь “большую” карточку, которая занимает две колонки. Попробуй `auto-fit/auto-fill` и увидишь, как сетка сама подстраивается под ширину экрана.",
    "code": ".grid{display:grid;grid-template-columns:repeat(3,1fr);gap:12px;}",
    "tasks": [
      "Сделай 2 колонки на телефоне и 4 на ПК.",
      "Сделай галерею 3×N."
    ]
  },
  {
    "id": 60,
    "lang": "CSS",
    "level": "Intermediate",
    "title": "CSS: media queries",
    "tags": [
      "responsive",
      "media"
    ],
    "explanation": "Media queries делают сайт адаптивным под разные экраны: телефон, планшет, ноутбук. Синтаксис: `@media (max-width: 768px) { ... }` — правила внутри применятся, когда ширина экрана меньше указанной. Обычно на маленьких экранах уменьшают шрифт, меняют сетку с 3 колонок на 1, увеличивают кнопки и отступы. Практика: возьми страницу с карточками и сделай так, чтобы на телефоне они шли в одну колонку, а на большом экране — в две или три. Проверь в инструментах разработчика (Device Toolbar). Адаптивность важна для SEO и рекламы: многие заходят с телефона, и Google оценивает удобство мобильной версии.",
    "code": "@media (max-width: 640px){\n  .grid{grid-template-columns:1fr;}\n}",
    "tasks": [
      "Спрячь боковую панель на телефоне.",
      "Уменьши заголовки на узких экранах."
    ]
  },
  {
    "id": 61,
    "lang": "JavaScript",
    "level": "Beginner",
    "title": "JS: let/const и типы",
    "tags": [
      "js",
      "let",
      "const"
    ],
    "explanation": "В JavaScript переменные объявляют через `let` и `const`. `const` используют, когда ссылка не должна меняться (например, элемент DOM или массив), а `let` — когда значение будет изменяться. JS имеет типы: number, string, boolean, object, undefined, null. Важно понимать, что JS может автоматически приводить типы, поэтому сравнение лучше делать через `===` (строгое). Практика: объяви несколько переменных, выведи их тип через `typeof`, попробуй сложить строку и число и посмотри, что получится. Эти основы нужны, чтобы уверенно работать с логикой сайта: фильтрами, поиском и обработкой событий.",
    "code": "const name = \"Ali\";\nlet score = 10;\nscore += 5;\nconsole.log(name, score);",
    "tasks": [
      "Создай переменные и выведи в консоль.",
      "Сделай template string `Привет, ${name}`."
    ]
  },
  {
    "id": 62,
    "lang": "JavaScript",
    "level": "Beginner",
    "title": "JS: функции и стрелки",
    "tags": [
      "functions",
      "arrow"
    ],
    "explanation": "Функции — главный инструмент для повторного использования кода в JavaScript. Есть обычные функции (`function name(){}`) и стрелочные (`const f = (x) => x*2`). Стрелочные функции короче и часто используются в обработчиках событий и методах массивов (`map`, `filter`). Важно понимать параметры, возвращаемое значение и область видимости. Практика: напиши функцию, которая форматирует текст (обрезает пробелы, приводит к lower), и используй её для поиска по урокам. Затем сделай стрелочную функцию для подсчёта совпадений. Хороший стиль — держать функции маленькими и с понятными именами: тогда код сайта легче поддерживать.",
    "code": "function add(a,b){return a+b;}\nconst sq = (x)=>x*x;\nconsole.log(add(2,3), sq(7));",
    "tasks": [
      "isEven(n)",
      "formatPrice(x)"
    ]
  },
  {
    "id": 63,
    "lang": "JavaScript",
    "level": "Intermediate",
    "title": "DOM: querySelector",
    "tags": [
      "dom",
      "querySelector"
    ],
    "explanation": "DOM — это представление HTML как дерева объектов, с которым можно работать из JavaScript. `document.querySelector()` позволяет найти элемент по CSS‑селектору, а `querySelectorAll()` — найти все совпадения. После этого можно менять текст (`textContent`), классы (`classList.add/remove`), атрибуты и создавать новые элементы. Это основа интерактивности: фильтры, поиск, открытие модалок, подгрузка карточек. Практика: найди кнопку, повесь на неё обработчик и меняй текст заголовка на странице. Затем найди список карточек и попробуй скрывать/показывать элементы по условию. Понимание DOM — ключ к тому, чтобы делать сайты “живыми”.",
    "code": "const title = document.querySelector('h1');\ntitle.textContent = 'Новый заголовок';",
    "tasks": [
      "Сделай кнопку: меняет текст блока.",
      "Добавь/убери класс по клику."
    ]
  },
  {
    "id": 64,
    "lang": "JavaScript",
    "level": "Intermediate",
    "title": "События: addEventListener",
    "tags": [
      "events",
      "click"
    ],
    "explanation": "События в браузере — это реакции на действия пользователя: клики, ввод текста, прокрутка, отправка формы. `addEventListener` позволяет подписаться на событие и выполнить функцию‑обработчик. Например, при вводе в поле поиска можно сразу фильтровать уроки, а при клике по карточке — открывать подробности. Важно помнить про `event.preventDefault()` для форм, чтобы страница не перезагружалась. Практика: сделай поле поиска и фильтрацию “на лету” по событию `input`. Затем добавь обработчик на кнопки фильтра и переключай активный класс. События — основа UX и превращают статичную страницу в приложение.",
    "code": "const btn = document.querySelector('#btn');\nbtn.addEventListener('click', ()=> alert('Клик!'));",
    "tasks": [
      "Счётчик кликов.",
      "Форма без перезагрузки (preventDefault)."
    ]
  },
  {
    "id": 65,
    "lang": "JavaScript",
    "level": "Intermediate",
    "title": "Массивы: map/filter/reduce",
    "tags": [
      "arrays",
      "map",
      "filter",
      "reduce"
    ],
    "explanation": "Массивы — ключевая структура данных в JavaScript. Методы `map`, `filter` и `reduce` позволяют красиво обрабатывать массивы без ручных циклов. `map` преобразует каждый элемент и возвращает новый массив, `filter` оставляет элементы по условию, `reduce` сворачивает массив в одно значение (сумма, объект, статистика). Эти методы идеально подходят для работы с уроками: фильтрация по теме/уровню, подсчёт количества найденных, построение списка тегов. Практика: отфильтруй уроки по языку, затем сделай `map` для вывода названий, а `reduce` — для подсчёта количества уроков по уровням. Такой стиль кода часто встречается в современном фронтенде.",
    "code": "const nums=[1,2,3,4,5];\nconsole.log(nums.map(x=>x*x));\nconsole.log(nums.filter(x=>x%2===0));\nconsole.log(nums.reduce((s,x)=>s+x,0));",
    "tasks": [
      "Сумма покупок reduce.",
      "Товары дороже 100 filter."
    ]
  },
  {
    "id": 66,
    "lang": "C++",
    "level": "Beginner",
    "title": "C++: Hello World",
    "tags": [
      "cpp",
      "iostream"
    ],
    "explanation": "Первый шаг в C++ — понять структуру программы и компиляцию. Обычно код начинается с `#include <iostream>`, функция `int main()` — точка входа, а вывод делают через `std::cout`. После `main` принято возвращать `0`, чтобы показать успешное завершение. В отличие от Python, C++ нужно компилировать: исходник `.cpp` превращается в исполняемый файл. Практика: собери программу “Hello, World!”, скомпилируй её и запусти. Затем добавь вывод нескольких строк, попробуй использовать `\\n` и сравни с `std::endl`. Понимание “компиляция → запуск” — основа для дальнейших тем в C++ и отличает его от интерпретируемых языков.",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n  cout << \"Hello, C++!\" << endl;\n  return 0;\n}",
    "tasks": [
      "Скомпилируй (g++ main.cpp -std=c++17 -O2).",
      "Выведи своё имя."
    ]
  },
  {
    "id": 67,
    "lang": "C++",
    "level": "Beginner",
    "title": "C++: ввод/вывод cin/cout",
    "tags": [
      "cpp",
      "cin",
      "cout"
    ],
    "explanation": "В C++ ввод делают через `std::cin`, вывод — через `std::cout`. Оператор `>>` читает значения, разделённые пробелами, а `<<` выводит данные в поток. Важно понимать типы: если читаешь `int`, ввод должен быть числом, иначе поток может перейти в ошибочное состояние. Для строк с пробелами используют `std::getline`. Практика: прочитай два числа и выведи сумму, затем попробуй прочитать имя и возраст и вывести фразу. После этого сравни `cin >> name` и `getline(cin, name)` на строке с пробелом — ты увидишь, почему `getline` иногда нужен обязательно.",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int a,b; cin>>a>>b;\n  cout << (a+b) << \"\\n\";\n}",
    "tasks": [
      "Считай 3 числа и выведи максимум.",
      "Считай строку через getline и выведи длину."
    ]
  },
  {
    "id": 68,
    "lang": "C++",
    "level": "Beginner",
    "title": "C++: условия и циклы",
    "tags": [
      "cpp",
      "if",
      "for",
      "while"
    ],
    "explanation": "Условия и циклы в C++ похожи на другие языки: `if/else` для ветвлений, `for` и `while` для повторений. Условие внутри `if` — логическое выражение, а блоки ограничиваются фигурными скобками `{}`. В цикле `for` обычно есть счётчик, условие и шаг. Также полезны `break` и `continue` для управления циклом. Практика: сделай проверку чётности числа и выведи результат. Затем посчитай сумму 1..n через `for`. После этого сделай цикл `while`, который спрашивает ввод, пока число не станет положительным. Такие упражнения закрепляют синтаксис и логику.",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n; cin>>n;\n  long long sum=0;\n  for(int i=1;i<=n;i++) sum+=i;\n  cout<<sum<<\"\\n\";\n}",
    "tasks": [
      "Сумма чётных 1..n.",
      "Таблица умножения на 5."
    ]
  },
  {
    "id": 69,
    "lang": "C++",
    "level": "Intermediate",
    "title": "C++: vector и sort",
    "tags": [
      "cpp",
      "vector",
      "sort"
    ],
    "explanation": "`std::vector` — динамический массив в C++, который удобно использовать вместо “сырых” массивов. Вектор умеет расти, а элементы доступны по индексу. Для сортировки обычно используют `std::sort` из `<algorithm>`. Важно помнить: `sort` требует итераторы начала и конца (`v.begin(), v.end()`). Практика: создай `vector<int>`, добавь элементы через `push_back`, выведи их, затем отсортируй и снова выведи. Попробуй сортировку по убыванию через `greater<int>()`. Вектор и sort — фундамент для задач на алгоритмы и соревнования, а также для работы со списками данных в обычных программах.",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n; cin>>n;\n  vector<int> v(n);\n  for(int i=0;i<n;i++) cin>>v[i];\n  sort(v.begin(), v.end());\n  for(int x: v) cout<<x<<\" \";\n}",
    "tasks": [
      "Сортировка по убыванию.",
      "Найди медиану."
    ]
  },
  {
    "id": 70,
    "lang": "C++",
    "level": "Intermediate",
    "title": "C++: функции",
    "tags": [
      "cpp",
      "functions"
    ],
    "explanation": "Функции в C++ помогают разделять программу на логические части. Функция имеет тип возвращаемого значения, имя и параметры. Если функция ничего не возвращает, используют `void`. Важно понимать передачу параметров: по значению (копия) и по ссылке (`&`), что позволяет изменять данные внутри функции и избегать лишних копирований. Практика: напиши функцию `int sum(int a, int b)` и функцию, которая принимает `vector<int>&` и находит максимум. Затем сделай функцию, которая меняет значение переменной через ссылку, и сравни с передачей по значению. Это даст понимание, почему ссылки важны для эффективности и контроля данных в C++.",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint sq(int x){return x*x;}\nint main(){\n  cout<<sq(7)<<\"\\n\";\n}",
    "tasks": [
      "Напиши gcd(a,b).",
      "Напиши isPrime(n) и протестируй."
    ]
  }
];
